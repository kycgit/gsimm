(defparameter *symbol-table*
    (list
     '+ '(:s-type op :t-op + :arg-n 2)
     '- '(:s-type op :t-op - :arg-n 2)
     '* '(:s-type op :t-op * :arg-n 2)
     '+r '(:s-type op :t-op +r :arg-n 2)
     '-r '(:s-type op :t-op -r :arg-n 2)
     '*r '(:s-type op :t-op *r :arg-n 2)
     '× '(:s-type op :t-op * :arg-n 2)
     '/ '(:s-type op :t-op / :arg-n 2)
     '/r '(:s-type op :t-op /r :arg-n 2)
     '÷ '(:s-type op :t-op / :arg-n 2)
     '< '(:s-type op :t-op < :arg-n 2)
     '<= '(:s-type op :t-op <= :arg-n 2)
     '> '(:s-type op :t-op > :arg-n 2)
     '>= '(:s-type op :t-op >= :arg-n 2)
     '= '(:s-type op :t-op = :arg-n 2)
     '/= '(:s-type op :t-op /= :arg-n 2)
     '0- '(:s-type op :t-op 0- :arg-n 1)
     '1/ '(:s-type op :t-op 1/ :arg-n 1)
     '√ '(:s-type op :t-op sqrt :arg-n 1)
     'inDeg '(:s-type op :t-op deg :arg-n 1)
     'toDeg '(:s-type op :t-op radTodeg :arg-n 1)	 
     'e^ '(:s-type op :t-op exp :arg-n 1)
     '^ '(:s-type op :t-op expt :arg-n 2)
     'e^r '(:s-type op :t-op exp-r :arg-n 1)
     '^r '(:s-type op :t-op expt-r :arg-n 2)
     ':ra '(:s-type op :t-op rational-approx-r :arg-n 2)
     'ln '(:s-type op :t-op log :arg-n 1)
     'log '(:s-type op :t-op log :arg-n 2)
     'ln-r '(:s-type op :t-op log-r :arg-n 1)
     'log-r '(:s-type op :t-op log-r :arg-n 2)))

(defun nroot (F &optional dg)
  (labels ((sign (x) (multiple-value-bind (a b c) (raw-approx-r x) a b c)))
    (let ((pct *CREAL-TOLERANCE*)
	  (gx 0)
	  eps)
      (if dg nil (setq dg *print-prec*))
      (setq *creal-tolerance* [ceiling (10 ^ dg log 2)])
      (setq eps [1/2 /r (10 ^ dg)])
      (loop while (not (= 0 (sign (funcall f gx))))
	    do (setq gx [eps *r 2 /r (funcall(f gx -r eps) -r funcall(f gx +r eps)) *r funcall(f gx) +r gx]))
      (setq *creal-tolerance* pct)
      gx)))

(defun nrootp (F &optional dg)
  (labels ((sign (x) (multiple-value-bind (a b c) (raw-approx-r x) a b c)))
    (let ((pct *CREAL-TOLERANCE*)
	  (gx 0)
	  eps)
      (if dg nil (setq dg *print-prec*))
      (setq *creal-tolerance* [ceiling (10 ^ dg log 2)])
      (setq eps [1/2 /r (10 ^ dg)])
      (print (loop while (not (= 0 (sign (funcall f gx))))
	    doing (setq gx [eps *r 2 /r (funcall(f gx -r eps) -r funcall(f gx +r eps)) *r funcall(f gx) +r gx])
	    collect gx))
      (setq *creal-tolerance* pct)
      gx)))
